#!/bin/bash
set -euo pipefail
trap 'echo "at line $LINENO, exit code $? from $BASH_COMMAND" >&2; exit 1' ERR

# This is a Claude Code hook to automatically suggest vtree visualization when appropriate.
#
# Installation:
# 1. Save this script and chmod +x it to make it executable.
# 2. Within Claude Code, /hooks / UserPromptSubmit > Add a new hook (this file)
#
# How it works:
# This script analyzes the assistant's recent responses to detect hierarchical structures,
# workflows, system architectures, and other content that would benefit from tree visualization.
# When detected, it appends a system reminder with appropriate vtree format templates.

stdin=$(cat)
transcript_path=$(echo "$stdin" | jq -r ".transcript_path")

# Get the last assistant response (excluding thinking blocks)
last_response=$(grep '"role":"assistant"' "$transcript_path" | tail -n 1)
[[ -z "$last_response" ]] && exit 0

# Extract text content
text_content=""
if [[ "$(jq -r '.message.content[0].type // empty' <<< "$last_response")" == "text" ]]; then
    text_content=$(jq -r '.message.content[0].text' <<< "$last_response")
fi

[[ -z "$text_content" ]] && exit 0

# Initialize full vtree flag
FULL_VTREE_REQUESTED=false

# Check for full vtree keywords in user messages (last few messages to catch requests)
last_user_messages=$(grep '"role":"user"' "$transcript_path" | tail -n 2)
if [[ -n "$last_user_messages" ]]; then
    while IFS= read -r user_msg; do
        if [[ "$(jq -r '.message.content[0].type // empty' <<< "$user_msg")" == "text" ]]; then
            user_text=$(jq -r '.message.content[0].text' <<< "$user_msg")
            if [[ "$user_text" =~ (\*vtree|show[[:space:]]full[[:space:]]vtree|detailed[[:space:]]vtree|vtree.*full|vtree.*detailed|comprehensive[[:space:]]vtree|expand[[:space:]]vtree|vtree.*complete|vtree.*all[[:space:]]details) ]]; then
                FULL_VTREE_REQUESTED=true
                break
            fi
        fi
    done <<< "$last_user_messages"
fi

# Comprehensive pattern detection for advanced vtree features
detect_advanced_patterns() {
    local text="$1"
    
    # Styling patterns
    local has_async=false
    local has_external=false
    local has_critical=false
    local has_optional=false
    
    # Advanced patterns
    local has_conditional=false
    local has_parallel=false
    local has_error_handling=false
    local has_performance=false
    local has_infrastructure=false
    local has_security=false
    
    # Detect async patterns
    if [[ "$text" =~ (async|await|promise|callback|defer|queue|background) ]]; then
        has_async=true
    fi
    
    # Detect external/third-party patterns
    if [[ "$text" =~ (api|external|third.party|service|client|remote|network|http) ]]; then
        has_external=true
    fi
    
    # Detect critical/main path patterns
    if [[ "$text" =~ (main|primary|critical|core|essential|key|important|required) ]]; then
        has_critical=true
    fi
    
    # Detect optional patterns
    if [[ "$text" =~ (optional|maybe|fallback|backup|alternative|cache) ]]; then
        has_optional=true
    fi
    
    # Detect conditional logic patterns
    if [[ "$text" =~ (if|condition|branch|decision|validate|check|success|fail) ]]; then
        has_conditional=true
    fi
    
    # Detect parallel processing patterns
    if [[ "$text" =~ (parallel|concurrent|simultaneous|fork|spawn|worker|thread) ]]; then
        has_parallel=true
    fi
    
    # Detect error handling patterns
    if [[ "$text" =~ (error|exception|fail|retry|fallback|handler|catch) ]]; then
        has_error_handling=true
    fi
    
    # Detect performance-related content
    if [[ "$text" =~ (performance|speed|latency|throughput|optimization|bottleneck) ]]; then
        has_performance=true
    fi
    
    # Detect infrastructure patterns
    if [[ "$text" =~ (deploy|kubernetes|docker|server|cluster|infrastructure) ]]; then
        has_infrastructure=true
    fi
    
    # Detect security patterns
    if [[ "$text" =~ (auth|security|permission|access|secure|encrypt|private) ]]; then
        has_security=true
    fi
    
    # Export all patterns for template generation
    export STYLE_ASYNC="$has_async"
    export STYLE_EXTERNAL="$has_external" 
    export STYLE_CRITICAL="$has_critical"
    export STYLE_OPTIONAL="$has_optional"
    export HAS_CONDITIONAL="$has_conditional"
    export HAS_PARALLEL="$has_parallel"
    export HAS_ERROR_HANDLING="$has_error_handling"
    export HAS_PERFORMANCE="$has_performance"
    export HAS_INFRASTRUCTURE="$has_infrastructure"
    export HAS_SECURITY="$has_security"
}

# Initialize scoring for vtree worthiness
score=0
content_type=""

# Check if vtree was already mentioned or provided
if [[ "$text_content" =~ [Vv]tree|tree.diagram|ASCII.tree ]]; then
    exit 0
fi


# Run comprehensive pattern detection early to influence scoring
detect_advanced_patterns "$text_content"

# Positive indicators scoring
# Workflow/process keywords (+2)
if [[ "$text_content" =~ (workflow|process|pipeline|procedure|sequence|steps|phases|stages) ]]; then
    score=$((score + 2))
    content_type="workflow"
fi

# Architecture/system keywords (+2)
if [[ "$text_content" =~ (architecture|system|framework|component|module|structure|hierarchy) ]]; then
    score=$((score + 2))
    content_type="architecture"
fi

# Multi-agent/component systems (+2)
if [[ "$text_content" =~ (agent|component|service|microservice|pipeline|network|chain) ]]; then
    score=$((score + 2))
    content_type="components"
fi

# Data flow indicators (+2)
if [[ "$text_content" =~ (‚Üí|->|input|output|transform|flow|data.flow|pipeline) ]]; then
    score=$((score + 2))
fi

# Numbered lists detection (+2)
numbered_lists=$(echo "$text_content" | grep -c '^[[:space:]]*[0-9]\+\.' || true)
if [[ $numbered_lists -ge 3 ]]; then
    score=$((score + 2))
fi

# Multi-level structure detection (+3)
# Look for nested patterns, indentation, or bullet points
if [[ "$text_content" =~ \-[[:space:]]*.*\n[[:space:]]*\-|[[:space:]]{4,}|‚îú‚îÄ|‚îî‚îÄ|‚îÇ ]]; then
    score=$((score + 3))
fi

# File operation detection (+3)
# Multiple file creates/edits suggest directory structure
file_ops=$(echo "$text_content" | grep -c -i 'create\|edit\|file\|directory\|folder' || true)
if [[ $file_ops -ge 3 ]]; then
    score=$((score + 3))
    content_type="files"
fi

# Decision trees (+2)
if [[ "$text_content" =~ (decision|choice|branch|condition|if.*then|case) ]]; then
    score=$((score + 2))
    content_type="decision"
fi

# Additional scoring based on comprehensive patterns
if [[ "$HAS_INFRASTRUCTURE" == "true" ]]; then
    score=$((score + 2))
fi

if [[ "$HAS_SECURITY" == "true" ]]; then
    score=$((score + 2))
fi

if [[ "$HAS_PERFORMANCE" == "true" ]]; then
    score=$((score + 1))
fi

if [[ "$HAS_PARALLEL" == "true" ]]; then
    score=$((score + 2))
fi

if [[ "$HAS_CONDITIONAL" == "true" ]]; then
    score=$((score + 1))
fi

if [[ "$HAS_ERROR_HANDLING" == "true" ]]; then
    score=$((score + 1))
fi

# Negative indicators
# Brief responses (-5)
char_count=${#text_content}
if [[ $char_count -lt 100 ]]; then
    score=$((score - 5))
fi

# Simple factual content (-3)
if [[ "$text_content" =~ ^(The|A|An)[[:space:]].*\.$|^[0-9]+$|^(Yes|No)\.?$|weather|temperature ]]; then
    score=$((score - 3))
fi

# Exit if score doesn't meet threshold
[[ $score -lt 5 ]] && exit 0

# Generate conditional logic notation
generate_conditional_notation() {
    local condition="$1"
    local success_node="$2"
    local failure_node="$3"
    echo "if($condition) ‚Üí ($success_node) else ‚Üí ($failure_node)"
}

# Generate parallel processing notation
generate_parallel_notation() {
    local nodes="$1"
    echo "‚Üí ($nodes)"
}

# Generate error handler node ID with .E suffix
generate_error_node_id() {
    local base_id="$1"
    echo "[$base_id.E]"
}

# Generate system grouping header
generate_system_header() {
    local section_name="$1"
    echo "# =========== ${section_name^^} ==========="
}

# Add inline comment
add_inline_comment() {
    local base_line="$1"
    local comment="$2"
    echo "$base_line  # $comment"
}

# Add performance metrics
add_performance_metrics() {
    local node_name="$1"
    local metrics="$2"
    echo "$node_name [$metrics]"
}

# Add infrastructure info
add_infrastructure_info() {
    local node_name="$1"
    local deployment="$2"
    echo "$node_name [@$deployment]"
}

# Add security markers
add_security_markers() {
    local node_name="$1"
    local auth_level="$2"
    echo "$node_name [Auth: $auth_level]"
}

# Get priority emoji based on content
get_priority_emoji() {
    local text="$1"
    if [[ "$text" =~ (critical|urgent|p0|high.priority) ]]; then
        echo "üî¥"
    elif [[ "$text" =~ (important|p1|medium.priority) ]]; then
        echo "üü°"
    else
        echo "üü¢"
    fi
}

# Get status emoji based on content
get_status_emoji() {
    local text="$1"
    if [[ "$text" =~ (running|active|executing) ]]; then
        echo "‚ö°"
    elif [[ "$text" =~ (waiting|pending|queued) ]]; then
        echo "‚è∏Ô∏è"
    elif [[ "$text" =~ (slow|bottleneck|performance) ]]; then
        echo "üêå"
    else
        echo "üîÑ"
    fi
}

# Apply selective styling to node names - no asterisks, meaningful hierarchy
apply_comprehensive_styling() {
    local node_name="$1"
    local styled_name="$node_name"
    
    # Apply priority indicators (keep these)
    if [[ "$node_name" =~ (critical|urgent) ]] || [[ "$STYLE_CRITICAL" == "true" ]]; then
        styled_name="üî¥ $styled_name"
    elif [[ "$node_name" =~ (important|key) ]]; then
        styled_name="üü° $styled_name"
    fi
    
    # Note: Text styling (bold/italic) will be applied directly in templates
    # without asterisks to avoid visual clutter and maintain semantic meaning
    
    echo "$styled_name"
}

# Simplified vtree template generation - minimal emojis, clean structure
generate_simplified_template() {
    local content_type="$1"
    local template=""
    
    case "$content_type" in
        "workflow"|"process")
            template="[1]  Process_Flow [üì• request] ‚Üí (2)
[2]  ‚îú‚îÄ Validation ‚Üí (3)
     ‚îú‚îÄ Processing ‚Üí (3)
     ‚îî‚îÄ Output_Generation ‚Üí (3)
[3]  Final_Result [üì§ response]"
            ;;
        "architecture"|"system")
            template="[1]  System_Architecture [üì• input] ‚Üí (2.1,2.2,2.3)
[2]  ‚îú‚îÄ Frontend_Layer ‚Üí (3)
     ‚îú‚îÄ API_Layer ‚Üí (3)
     ‚îî‚îÄ Backend_Layer ‚Üí (3)
[3]  Response_Handler [üì§ output]"
            ;;
        "components"|"agents")
            template="[1]  Orchestrator [üì• request] ‚Üí (2.1,2.2,2.3)
[2]  ‚îú‚îÄ Agent_Research ‚Üí (3)
     ‚îú‚îÄ Agent_Analysis ‚Üí (3)
     ‚îî‚îÄ Agent_Execution ‚Üí (3)
[3]  Result_Combiner [üì§ final]"
            ;;
        "files"|"directory")
            template="[1]  Project_Structure [üì• files] ‚Üí (2.1,2.2)
[2]  ‚îú‚îÄ Source_Code ‚Üí (3)
     ‚îî‚îÄ Tests ‚Üí (3)
[3]  Build_Output [üì§ artifacts]"
            ;;
        "decision")
            template="[1]  Decision_Point [üì• criteria] ‚Üí (2,3,4)
[2]  ‚îú‚îÄ Option_A ‚Üí (END)
[3]  ‚îú‚îÄ Option_B ‚Üí (END)
[4]  ‚îî‚îÄ Default ‚Üí (END)"
            ;;
        *)
            template="[1]  Main_Component [üì• input] ‚Üí (2.1,2.2)
[2]  ‚îú‚îÄ Sub_Component_A ‚Üí (3)
     ‚îî‚îÄ Sub_Component_B ‚Üí (3)
[3]  Output_Handler [üì§ result]"
            ;;
    esac
    
    echo "$template"
}

# Enhanced vtree template generation with emojis, node IDs, and intelligent styling
generate_enhanced_template() {
    local content_type="$1"
    local template=""
    
    # Analyze content for comprehensive patterns
    detect_advanced_patterns "$text_content"
    
    case "$content_type" in
        "workflow"|"process")
            if [[ "$HAS_CONDITIONAL" == "true" && "$HAS_ERROR_HANDLING" == "true" ]]; then
                template="# =========== PROCESSING LAYER ===========
[1]     üî¥ **Workflow_Orchestrator** [üì• request] ‚Üí [üöÄ result ‚Üê (1.1)+(1.2)]
[1.1]   ‚îú‚îÄ Validator [üì• data ‚Üê (1)] ‚Üí [if(valid) ‚Üí (1.2) else ‚Üí (1.1.E)]
[1.1.1] ‚îÇ  ‚îú‚îÄ Schema_Check [‚ö° 2.1ms] ‚Üí [‚úÖ ‚Üí (1.1)]
[1.1.2] ‚îÇ  ‚îî‚îÄ Rate_Limiter [@redis-cluster] ‚Üí [‚úÖ ‚Üí (1.1)]
[1.1.E] ‚îÇ  ‚îî‚îÄ ‚ùå Error_Handler ‚Üí [üì§ error ‚Üí (1)]
[1.2]   ‚îî‚îÄ Async_Processor [‚è≥ background] ‚Üí [üì§ ‚Üí (1)]  # ML Pipeline"
            else
                template="[1]     **Process_Orchestrator** [üì• request] ‚Üí [üöÄ result ‚Üí (END)]
[1.1]   ‚îú‚îÄ Step_1 [üì• raw ‚Üê (1)] ‚Üí [üîÑ processed ‚Üí (1.2)]
[1.2]   ‚îú‚îÄ Step_2 [üìä data ‚Üê (1.1)] ‚Üí [‚úÖ validated ‚Üí (1.3)]
[1.3]   ‚îî‚îÄ Step_3 [üíæ validated ‚Üê (1.2)] ‚Üí [üì§ final ‚Üí (1)]"
            fi
            ;;
        "architecture"|"system")
            if [[ "$HAS_INFRASTRUCTURE" == "true" && "$HAS_SECURITY" == "true" ]]; then
                template="# =========== FRONTEND LAYER ===========
[1]     üåê **Load_Balancer** [@nginx-ingress] ‚Üí [üéØ ‚Üí (1.1,1.2,1.3)]
[1.1]   ‚îú‚îÄ Web_Server_1 [‚ö° 1.2ms, 99.9% uptime] ‚Üí [üì§ ‚Üí (2)]
[1.2]   ‚îú‚îÄ Web_Server_2 [‚ö° 1.4ms, 99.8% uptime] ‚Üí [üì§ ‚Üí (2)]
[1.3]   ‚îî‚îÄ Web_Server_3 [üêå 5.2ms, 95% uptime] ‚Üí [üì§ ‚Üí (2)]

# =========== API LAYER ===========
[2]     üîí **API_Gateway** [Auth: oauth2] ‚Üí [if(authenticated) ‚Üí (3) else ‚Üí (2.E)]
[2.E]   ‚îî‚îÄ ‚ùå Auth_Failure ‚Üí [üì§ 401_error]

# =========== DATA LAYER ===========
[3]     üíæ Database_Cluster [@kubernetes-prod, CPU: 16 cores] ‚Üí [üì§ data]"
            else
                template="[1]     **System_Orchestrator** [üì• user_request] ‚Üí [üì§ response ‚Üí (END)]
[1.1]   ‚îú‚îÄ Frontend_Layer [üì• UI_events ‚Üê (1)] ‚Üí [üéØ API_calls ‚Üí (1.2)]
[1.2]   ‚îú‚îÄ API_Layer [üì• requests ‚Üê (1.1)] ‚Üí [üîÑ data ‚Üí (1.3)]
[1.3]   ‚îî‚îÄ Backend_Layer [üì• queries ‚Üê (1.2)] ‚Üí [üíæ results ‚Üí (1.2)]"
            fi
            ;;
        "components"|"agents")
            if [[ "$HAS_PARALLEL" == "true" ]]; then
                template="# =========== ORCHESTRATION LAYER ===========
[1]     üî¥ **Master_Controller** [üì• request] ‚Üí [üéØ ‚Üí (2.1||2.2||2.3)]
[2.1]   ‚îú‚îÄ ‚ö° Research_Agent [@aws-lambda, 4GB] ‚Üí [üìä analysis ‚Üí (3)]
[2.2]   ‚îú‚îÄ ‚ö° Code_Agent [üîí Auth: service] ‚Üí [üíª code ‚Üí (3)]
[2.3]   ‚îî‚îÄ ‚ö° QA_Agent [‚è∏Ô∏è Rate: 100/min] ‚Üí [‚úÖ validated ‚Üí (3)]

# =========== AGGREGATION LAYER ===========
[3]     üü° **Result_Combiner** [üì• ‚Üê (2.1)+(2.2)+(2.3)] ‚Üí [üöÄ final]
[3.E]   Emergency_Fallback ‚Üê (2.1,2.2,2.3) ‚Üí [üîß recovery]  # Auto-retry logic"
            else
                template="[1]     **Agent_Orchestrator** [üì• request] ‚Üí [üéØ distribute ‚Üí (2.1,2.2,2.3)]
[2.1]   ‚îú‚îÄ Agent_A [üì• task ‚Üê (1)] ‚Üí [‚ö° result_a ‚Üí (3)]
[2.2]   ‚îú‚îÄ Agent_B [üì• data ‚Üê (1)] ‚Üí [üîÑ result_b ‚Üí (3)]
[2.3]   ‚îî‚îÄ Agent_C [‚è≥ task ‚Üê (1)] ‚Üí [üì§ result_c ‚Üí (3)]
[3]     **Result_Coordinator** [üì• results ‚Üê (2.1)+(2.2)+(2.3)] ‚Üí [üì§ final]"
            fi
            ;;
        "files"|"directory")
            template="# =========== PROJECT STRUCTURE ===========
[1]     **Project_Organizer** [üì• files] ‚Üí [üì§ organized ‚Üí (END)]
[1.1]   ‚îú‚îÄ src/ [üì• source ‚Üê (1)] ‚Üí [üíª compiled ‚Üí (1.3)]
[1.1.1] ‚îÇ  ‚îú‚îÄ components/ [üì• ‚Üê (1.1)] ‚Üí [üîÑ ‚Üí (1.1)]  # React Components
[1.1.2] ‚îÇ  ‚îî‚îÄ utils/ [üì• ‚Üê (1.1)] ‚Üí [üîÑ ‚Üí (1.1)]  # Helper Functions
[1.2]   ‚îî‚îÄ tests/ [üì• specs ‚Üê (1)] ‚Üí [‚úÖ validated ‚Üí (1.3)]
[1.3]   Build_Output [üì• ‚Üê (1.1)+(1.2)] ‚Üí [üì§ ‚Üê (1)]"
            ;;
        "decision")
            template="[1]     **Decision_Controller** [üì• criteria] ‚Üí [üéØ choice ‚Üí (2,3,4)]
[2]     Condition_A [üì• check ‚Üê (1)] ‚Üí [if(passes) ‚Üí (END) else ‚Üí (3)]
[3]     Condition_B [üì• check ‚Üê (1)] ‚Üí [if(passes) ‚Üí (END) else ‚Üí (4)]
[4]     üü° Default_Handler [üì• fallback ‚Üê (1)] ‚Üí [üì§ default_action ‚Üí (END)]
[4.E]   ‚ùå Error_State ‚Üê (2,3,4) ‚Üí [üîß emergency_stop]  # Circuit breaker"
            ;;
        *)
            template="[1]     üü¢ **System_Orchestrator** [üì• params] ‚Üí [üì§ results ‚Üí (END)]
[1.1]   ‚îú‚îÄ Component_1 [üì• data ‚Üê (1)] ‚Üí [üîÑ processed ‚Üí (1.2)]
[1.2]   ‚îú‚îÄ Component_2 [üì• processed ‚Üê (1.1)] ‚Üí [‚ö° enhanced ‚Üí (1.3)]
[1.3]   ‚îî‚îÄ Component_3 [üì• enhanced ‚Üê (1.2)] ‚Üí [üì§ final ‚Üí (1)]"
            ;;
    esac
    
    echo "$template"
}

# Generate the appropriate template based on request type
if [[ "$FULL_VTREE_REQUESTED" == "true" ]]; then
    vtree_template=$(generate_enhanced_template "$content_type")
    VTREE_MODE="full"
else
    vtree_template=$(generate_simplified_template "$content_type")
    VTREE_MODE="simplified"
fi

# Generate system reminder based on mode
generate_vtree_system_reminder() {
    local mode="$1"
    local template="$2"
    
    # Find the formats directory relative to this script
    local script_dir="$(dirname "${BASH_SOURCE[0]}")"
    local formats_file="$script_dir/../formats/vtree-format.md"
    
    # Check if the format file exists
    if [[ ! -f "$formats_file" ]]; then
        # Fallback to basic format if file doesn't exist
        echo "<system-reminder>Generate a vtree diagram for the hierarchical content.</system-reminder>"
        return
    fi
    
    # Extract appropriate format instructions based on mode
    local format_instructions=""
    if [[ "$mode" == "simplified" ]]; then
        # Extract simplified format section (exclude the ending header)
        format_instructions=$(sed -n '/## Simplified Format/,/## Comprehensive Format/p' "$formats_file" | sed '$d')
        # Add introduction and template
        cat <<EOF
<system-reminder>
The response you just provided describes a hierarchical structure, workflow, or system that would benefit from ASCII tree visualization.

Please append a vtree diagram at the end of your response using this format:

\`\`\`
$template
\`\`\`

$format_instructions

For detailed vtree with performance metrics, security annotations, error handlers, and infrastructure details, type "*vtree" in your next message.

Add a brief note: "Simplified vtree for quick understanding" after the diagram.
</system-reminder>
EOF
    else
        # Extract comprehensive format section (exclude the ending header)
        format_instructions=$(sed -n '/## Comprehensive Format/,/## Usage Guidelines/p' "$formats_file" | sed '$d')
        # Add introduction and template
        cat <<EOF
<system-reminder>
The response you just provided describes a hierarchical structure, workflow, or system that would benefit from comprehensive ASCII tree visualization.

Please append a comprehensive vtree diagram at the end of your response using this exact format:

\`\`\`
$template
\`\`\`

$format_instructions

Add a brief note: "Comprehensive vtree optimized for terminal display with advanced semantic indicators" after the diagram.
</system-reminder>
EOF
    fi
}

# Call the function to generate the system reminder
generate_vtree_system_reminder "$VTREE_MODE" "$vtree_template"

exit 0