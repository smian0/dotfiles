"""
Workflow Tree Visualizer for Claude Agent SDK

Displays workflow execution as a visual ASCII tree with timing,
tool calls, and metrics. Inspired by Agno's workflow debugger.

Usage:
    from workflow_tree_visualizer import visualize_workflow

    # From log file
    visualize_workflow(log_file="logs/20251017_173252_tech_comparison.log")

    # From JSONL transcript
    visualize_workflow(transcript_file="transcript.jsonl", verbose=True)
"""

import json
import re
from pathlib import Path
from datetime import datetime
from typing import Optional, List, Dict, Any
from rich.console import Console
from rich.tree import Tree
from rich.panel import Panel
from rich.table import Table


class WorkflowTreeVisualizer:
    """
    Visualizes Claude Agent SDK workflow execution as an ASCII tree.

    Supports both log files (from WorkflowLogger) and JSONL transcripts.
    """

    def __init__(self, console: Optional[Console] = None):
        self.console = console or Console()
        self.events = []
        self.workflow_name = "Workflow"
        self.start_time = None
        self.tool_calls = []

    def load_from_log(self, log_file: str):
        """Parse log file generated by WorkflowLogger."""
        log_path = Path(log_file)
        if not log_path.exists():
            raise FileNotFoundError(f"Log file not found: {log_file}")

        with open(log_path, 'r') as f:
            content = f.read()

        # Extract workflow name from header
        workflow_match = re.search(r'Workflow Log: (\w+)', content)
        if workflow_match:
            self.workflow_name = workflow_match.group(1)

        # Extract start time
        start_match = re.search(r'Started: (.+)', content)
        if start_match:
            self.start_time = datetime.fromisoformat(start_match.group(1))

        # Parse tool use events
        lines = content.split('\n')
        current_tool = None

        for line in lines:
            # Match tool start: [17:33:01.278] [TOOL] üîß Using tool: unknown
            tool_start = re.search(r'\[(\d+:\d+:\d+\.\d+)\] \[TOOL\] üîß Using tool: (.+)', line)
            if tool_start:
                timestamp_str = tool_start.group(1)
                tool_name = tool_start.group(2)
                current_tool = {
                    'timestamp': timestamp_str,
                    'name': tool_name,
                    'input': None,
                    'output': None,
                    'tool_id': None
                }
                continue

            # Match tool ID
            if current_tool and 'Tool ID:' in line:
                tool_id_match = re.search(r'Tool ID: (.+)', line)
                if tool_id_match:
                    current_tool['tool_id'] = tool_id_match.group(1).strip()

            # Match input (starts with "Input:")
            if current_tool and line.strip().startswith('"Input:') or (current_tool and 'Input:' in line and '{' in line):
                # Start capturing JSON input
                current_tool['capturing_input'] = True
                current_tool['input_lines'] = []

            # Capture JSON lines
            if current_tool and current_tool.get('capturing_input'):
                # Look for JSON content
                if '{' in line or '[' in line or line.strip().endswith(',') or line.strip().endswith('}'):
                    current_tool['input_lines'].append(line)
                # End of JSON
                if '}' in line and not line.strip().endswith(','):
                    current_tool['capturing_input'] = False
                    try:
                        # Try to parse accumulated JSON
                        json_str = '\n'.join(current_tool['input_lines'])
                        # Extract just the JSON part
                        json_match = re.search(r'(\{.*\})', json_str, re.DOTALL)
                        if json_match:
                            current_tool['input'] = json.loads(json_match.group(1))
                    except json.JSONDecodeError:
                        pass

            # Match tool completion
            if current_tool and '‚úÖ Completed:' in line:
                self.tool_calls.append(current_tool)
                current_tool = None

    def load_from_transcript(self, transcript_file: str):
        """Parse JSONL transcript from Claude Code."""
        transcript_path = Path(transcript_file)
        if not transcript_path.exists():
            raise FileNotFoundError(f"Transcript file not found: {transcript_file}")

        with open(transcript_path, 'r') as f:
            for line in f:
                if line.strip():
                    entry = json.loads(line)
                    self.events.append(entry)

        # Extract tool calls from transcript
        for entry in self.events:
            if entry.get('type') != 'assistant':
                continue

            message = entry.get('message', {})
            content = message.get('content', [])
            timestamp = entry.get('timestamp', '')

            for item in content:
                if isinstance(item, dict) and item.get('type') == 'tool_use':
                    self.tool_calls.append({
                        'timestamp': timestamp,
                        'name': item.get('name'),
                        'input': item.get('input'),
                        'tool_id': item.get('id')
                    })

    def show_tree(self, verbose: bool = False):
        """
        Display workflow execution as ASCII tree.

        Args:
            verbose: If True, show detailed input/output data
        """
        self.console.print("\n[bold cyan]üìä Workflow Execution Tree[/bold cyan]")

        if self.start_time:
            self.console.print(f"[dim]Started: {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}[/dim]")

        self.console.print(f"[dim]Total tool calls: {len(self.tool_calls)}[/dim]\n")

        # Create tree structure
        tree = Tree(
            f"[bold green]üå≥ {self.workflow_name}[/bold green]",
            guide_style="dim"
        )

        if not self.tool_calls:
            tree.add("[yellow]No tool calls recorded[/yellow]")
        else:
            # Group sequential tool calls
            for idx, tool in enumerate(self.tool_calls):
                # Format tool info
                tool_name = tool.get('name', 'Unknown')
                timestamp = tool.get('timestamp', '')
                tool_id = tool.get('tool_id', '')

                # Create tool node
                tool_label = f"[magenta]üîß {tool_name}[/magenta]"
                if timestamp:
                    tool_label += f" [dim]({timestamp})[/dim]"

                tool_node = tree.add(tool_label)

                # Add tool ID
                if tool_id and verbose:
                    tool_node.add(f"[dim]ID: {tool_id[:20]}...[/dim]")

                # Add input if available
                if tool.get('input'):
                    input_data = tool['input']

                    if verbose:
                        # Show full input in verbose mode
                        input_str = json.dumps(input_data, indent=2)
                        if len(input_str) > 500:
                            input_str = input_str[:500] + "..."
                        input_node = tool_node.add("[yellow]Input:[/yellow]")
                        for line in input_str.split('\n'):
                            input_node.add(f"[dim]{line}[/dim]")
                    else:
                        # Show summary in normal mode
                        if isinstance(input_data, dict):
                            # Show key fields
                            summary_parts = []
                            for key in ['session_id', 'tool_name', 'todos', 'query']:
                                if key in input_data:
                                    value = input_data[key]
                                    if isinstance(value, list):
                                        summary_parts.append(f"{key}: {len(value)} items")
                                    elif isinstance(value, str) and len(value) > 50:
                                        summary_parts.append(f"{key}: {value[:50]}...")
                                    else:
                                        summary_parts.append(f"{key}: {value}")

                            if summary_parts:
                                tool_node.add(f"[yellow]Input:[/yellow] [dim]{', '.join(summary_parts)}[/dim]")

        self.console.print(tree)
        self.console.print()

    def show_metrics(self):
        """Show workflow metrics summary."""
        if not self.tool_calls:
            return

        self.console.print("[bold cyan]üìà Metrics Summary[/bold cyan]\n")

        # Count tool usage
        tool_counts = {}
        for tool in self.tool_calls:
            name = tool.get('name', 'Unknown')
            tool_counts[name] = tool_counts.get(name, 0) + 1

        # Create metrics table
        table = Table(title="Tool Usage", show_header=True)
        table.add_column("Tool", style="magenta")
        table.add_column("Calls", justify="right", style="cyan")

        for tool_name, count in sorted(tool_counts.items(), key=lambda x: x[1], reverse=True):
            table.add_row(tool_name, str(count))

        self.console.print(table)
        self.console.print()

    def show_timeline(self):
        """Show chronological timeline of events."""
        if not self.tool_calls:
            return

        self.console.print("[bold cyan]‚è±Ô∏è  Timeline[/bold cyan]\n")

        for idx, tool in enumerate(self.tool_calls, 1):
            timestamp = tool.get('timestamp', '')
            tool_name = tool.get('name', 'Unknown')

            # Format timeline entry
            prefix = "‚îú‚îÄ" if idx < len(self.tool_calls) else "‚îî‚îÄ"
            self.console.print(
                f"[dim]{prefix}[/dim] [{timestamp}] [magenta]{tool_name}[/magenta]"
            )

        self.console.print()


def visualize_workflow(
    log_file: Optional[str] = None,
    transcript_file: Optional[str] = None,
    verbose: bool = False,
    show_metrics: bool = True,
    show_timeline: bool = False
):
    """
    Visualize workflow execution from log or transcript file.

    Args:
        log_file: Path to WorkflowLogger log file
        transcript_file: Path to JSONL transcript file
        verbose: If True, show detailed information
        show_metrics: If True, show metrics summary
        show_timeline: If True, show chronological timeline

    Example:
        # From log file
        visualize_workflow(log_file="logs/20251017_173252_tech_comparison.log")

        # From transcript with full details
        visualize_workflow(
            transcript_file="transcript.jsonl",
            verbose=True,
            show_metrics=True,
            show_timeline=True
        )
    """
    visualizer = WorkflowTreeVisualizer()

    # Load data
    if log_file:
        visualizer.load_from_log(log_file)
    elif transcript_file:
        visualizer.load_from_transcript(transcript_file)
    else:
        raise ValueError("Must provide either log_file or transcript_file")

    # Display tree
    visualizer.show_tree(verbose=verbose)

    # Optional displays
    if show_metrics:
        visualizer.show_metrics()

    if show_timeline:
        visualizer.show_timeline()


# CLI interface
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Visualize Claude Agent SDK workflow execution"
    )
    parser.add_argument(
        "--log", "-l",
        help="Path to workflow log file"
    )
    parser.add_argument(
        "--transcript", "-t",
        help="Path to JSONL transcript file"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Show detailed information"
    )
    parser.add_argument(
        "--metrics", "-m",
        action="store_true",
        default=True,
        help="Show metrics summary (default: True)"
    )
    parser.add_argument(
        "--timeline",
        action="store_true",
        help="Show chronological timeline"
    )

    args = parser.parse_args()

    if not args.log and not args.transcript:
        parser.error("Must provide either --log or --transcript")

    visualize_workflow(
        log_file=args.log,
        transcript_file=args.transcript,
        verbose=args.verbose,
        show_metrics=args.metrics,
        show_timeline=args.timeline
    )
